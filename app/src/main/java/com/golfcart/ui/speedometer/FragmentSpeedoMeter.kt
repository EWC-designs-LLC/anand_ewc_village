package com.golfcart.ui.speedometer

import android.annotation.SuppressLint
import android.graphics.Typeface
import android.location.Location
import android.os.Bundle
import android.view.View
import androidx.fragment.app.Fragment
import com.golfcart.BR
import com.golfcart.R
import com.golfcart.databinding.FragmentSpeedometerBinding
import com.golfcart.model.app_interface.PermissionListener
import com.golfcart.model.toolbar_configuration.ToolbarConfiguration
import com.golfcart.ui.village.VillageFragment
import com.golfcart.utils.village_constant.VillageConstants.FONT_TYPE
import com.mapbox.geojson.FeatureCollection
import com.mapbox.geojson.Point
import com.mapbox.mapboxsdk.geometry.LatLng
import com.mapbox.maps.CameraOptions
import com.mapbox.maps.extension.style.sources.generated.geoJsonSource
import com.mapbox.maps.extension.style.style
import com.mapbox.maps.plugin.animation.camera
import com.mapbox.maps.plugin.locationcomponent.location
import com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI
import com.mapbox.navigation.base.options.NavigationOptions
import com.mapbox.navigation.core.MapboxNavigation
import com.mapbox.navigation.core.lifecycle.MapboxNavigationApp
import com.mapbox.navigation.core.lifecycle.MapboxNavigationObserver
import com.mapbox.navigation.core.lifecycle.requireMapboxNavigation
import com.mapbox.navigation.core.trip.session.LocationMatcherResult
import com.mapbox.navigation.core.trip.session.LocationObserver
import com.mapbox.navigation.ui.maps.location.NavigationLocationProvider
import org.koin.androidx.viewmodel.ext.android.viewModel

@OptIn(ExperimentalPreviewMapboxNavigationAPI::class)
class FragmentSpeedoMeter : VillageFragment<FragmentSpeedometerBinding, SpeedometerViewModel>() {

    private var mapBox: com.mapbox.maps.MapboxMap? = null
    private val BOUNDS_ID = "BOUNDS_ID"
    private val navigationLocationProvider = NavigationLocationProvider()

    /*
     * [NavigationLocationProvider] is a utility class that helps to provide location updates generated by the Navigation SDK
     * to the Maps SDK in order to update the user location indicator on the map
     * Gets notified with location updates.
     * Exposes raw updates coming directly from the location services
     * and the updates enhanced by the Navigation SDK (cleaned up and matched to the road).
     * */
    var firstTimeUpdate = true
    var enhancedLocation: Location? = null
    private val locationObserver = object : LocationObserver {
        override fun onNewRawLocation(rawLocation: Location) {}
        override fun onNewLocationMatcherResult(locationMatcherResult: LocationMatcherResult) {
            enhancedLocation = locationMatcherResult.enhancedLocation
            navigationLocationProvider.changePosition(
                enhancedLocation!!,
                locationMatcherResult.keyPoints,
            )
            // Invoke this method to move the camera to your current location.
            if (firstTimeUpdate) {
                updateCamera(enhancedLocation!!)
                firstTimeUpdate = false
            }

        }
    }


    override fun showBottomBar(): Boolean? {
        return true
    }

    override fun getCurrentFragment(): Fragment? {
        return this@FragmentSpeedoMeter
    }

    override fun showToolbar(): Boolean? {
        return true
    }

    override fun configureToolbar(): ToolbarConfiguration? {
        return ToolbarConfiguration(
            false, true, getString(R.string.speedometer), false, -1, false, "", false, -1
        )
    }

    override fun getBindingVariable(): Int {
        return BR.speedometer
    }

    override fun getLayoutId(): Int {
        return R.layout.fragment_speedometer
    }

    override fun getViewModel(): SpeedometerViewModel {
        val vm: SpeedometerViewModel by viewModel()
        return vm
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        setViews()
        fetchLocation()
    }

    private fun loadMap() {

        getViewDataBinding()!!.apply {

            mapBox?.loadStyle(
                style(com.mapbox.maps.Style.OUTDOORS) {
                    +geoJsonSource(BOUNDS_ID) {
                        featureCollection(FeatureCollection.fromFeatures(listOf()))
                    }
                }
            ) {
                getViewDataBinding()!!.mapView.location.updateSettings {
                    enabled = true
                    pulsingEnabled = true
                }
            }

        }
    }

    private fun initiliase() {
        mapBox = getViewDataBinding()!!.mapView.getMapboxMap()
        loadMap()
    }

    var oneTime = true
    var latLng: LatLng? = null
    var myLatLng: LatLng? = null
    fun fetchLocation() {
        locationPermission(object : PermissionListener {
            override fun onAccepted(lat: Any, lng: Any) {
                if (oneTime && lat != null) {
                    oneTime = false
                    latLng = LatLng(lat as Double, lng as Double)
                    myLatLng = latLng
                    initiliase()
                }
            }
        })
    }

    override fun onStart() {
        super.onStart()
        getViewDataBinding()!!.mapView.onStart()
    }

    override fun onStop() {
        super.onStop()
        getViewDataBinding()!!.mapView.onStop()
    }

    override fun onLowMemory() {
        super.onLowMemory()
        getViewDataBinding()!!.mapView.onLowMemory()
    }

    override fun onDestroy() {
        super.onDestroy()
        getViewDataBinding()!!.mapView.onDestroy()
    }

    private fun updateCamera(location: Location) {
        getViewDataBinding()!!.mapView.camera.easeTo(
            CameraOptions.Builder()
                // Centers the camera to the lng/lat specified.
                .center(Point.fromLngLat(location.longitude, location.latitude))
                // specifies the zoom value. Increase or decrease to zoom in or zoom out
                .zoom(18.0)
                // specify frame of reference from the center.
                //.padding(EdgeInsets(500.0, 0.0, 0.0, 0.0))
                .build(),
            null
        )
    }

    private val mapboxNavigation: MapboxNavigation by requireMapboxNavigation(
        onResumedObserver = object : MapboxNavigationObserver {
            @SuppressLint("MissingPermission")
            override fun onAttached(mapboxNavigation: MapboxNavigation) {
                mapboxNavigation.registerLocationObserver(locationObserver)
                mapboxNavigation.startTripSession()
            }

            override fun onDetached(mapboxNavigation: MapboxNavigation) {
                mapboxNavigation.unregisterLocationObserver(locationObserver)
            }
        },
        onInitialize = this::initNavigation
    )

    private fun initNavigation() {
        MapboxNavigationApp.setup(
            NavigationOptions.Builder(getContainerActivity())
                .accessToken(getString(R.string.mapbox_access_token))
                .build()
        )
    }

    private fun setViews() {
        getViewDataBinding()!!.apply {
            tvMiles.setTypeface(
                Typeface.createFromAsset(
                    getContainerActivity().assets,
                    FONT_TYPE
                )
            )
        }
    }


}

/*var mapbox: MapboxMap? = null

override fun showBottomBar(): Boolean {
    return true
}

override fun getCurrentFragment(): Fragment {
    return this@FragmentSpeedoMeter
}

override fun showToolbar(): Boolean {
    return true
}

override fun configureToolbar(): ToolbarConfiguration {
    return ToolbarConfiguration(
        false, true, getString(R.string.home),
        true, R.drawable.ic_search_home, true, "83 F Clear", false, -1
    )
}

override fun getBindingVariable(): Int {
    return BR.speedometer
}

override fun getLayoutId(): Int {
    return R.layout.fragment_speedometer
}

override fun getViewModel(): SpeedometerViewModel {
    val vm: SpeedometerViewModel by viewModel()
    return vm
}

override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
    super.onViewCreated(view, savedInstanceState)
    setViews()
    fetchLocation()
}

private fun setViews() {
    getViewDataBinding()!!.apply {
        tvMiles.setTypeface(
            Typeface.createFromAsset(
                getContainerActivity().assets,
                FONT_TYPE
            )
        )
    }
}

var oneTime = true
var latLng: LatLng? = null
fun fetchLocation() {
    locationPermission(object : PermissionListener {
        override fun onAccepted(lat: Any, lng: Any) {
            if (oneTime && lat != null) {
                oneTime = false
                latLng = LatLng(lat as Double, lng as Double)
                initiliase()
            }
        }
    })
}

private fun initiliase() {
    getViewDataBinding()!!.mapView.getMapAsync(this@FragmentSpeedoMeter)
}

override fun onMapReady(mapboxMap: MapboxMap) {
    mapbox = mapboxMap
    mapboxMap.setStyle(Style.Builder().fromUrl(Style.OUTDOORS)) {
        enableLocationComponent(it)

        mapboxMap!!.getUiSettings().setAttributionEnabled(false);
        mapboxMap!!.getUiSettings().setLogoEnabled(false);
        mapboxMap!!.uiSettings.isTiltGesturesEnabled = false
    }

    val boundsBuilder = LatLngBounds.Builder()
    boundsBuilder.include(latLng!!)
    val bounds = boundsBuilder.build()
    mapbox?.easeCamera(CameraUpdateFactory.newLatLngBounds(bounds, 1000), 2000)
}

@SuppressLint("MissingPermission")
private fun enableLocationComponent(loadedMapStyle: Style) {
    // Check if permissions are enabled and if not request
    if (PermissionsManager.areLocationPermissionsGranted(getContainerActivity())) {

        // Create and customize the LocationComponent's options
        val customLocationComponentOptions =
            LocationComponentOptions.builder(getContainerActivity())
                .trackingGesturesManagement(true)
                .accuracyColor(
                    ContextCompat.getColor(
                        getContainerActivity(),
                        R.color.mapboxGreen
                    )
                )
                .build()

        val locationComponentActivationOptions =
            LocationComponentActivationOptions.builder(getContainerActivity(), loadedMapStyle)
                .locationComponentOptions(customLocationComponentOptions)
                .build()

        // Get an instance of the LocationComponent and then adjust its settings
        mapbox!!.locationComponent.apply {

            // Activate the LocationComponent with options
            activateLocationComponent(locationComponentActivationOptions)

            // Enable to make the LocationComponent visible
            isLocationComponentEnabled = true

            // Set the LocationComponent's camera mode
            cameraMode = CameraMode.TRACKING

            // Set the LocationComponent's render mode
            renderMode = RenderMode.COMPASS
        }
    }
}

}*/